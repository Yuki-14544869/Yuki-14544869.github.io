---
title: hihoCoder-1324 希尔伯特曲线
date: 2017-08-16 23:14:16
tags:
  - ACM
  - hiho
  - 分治
---

# [#1324 : 希尔伯特曲线](http://hihocoder.com/problemset/problem/1324)
## 描述
希尔伯特曲线是以下一系列分形曲线 Hn 的极限。我们可以把 Hn 看作一条覆盖 2n × 2n 方格矩阵的曲线，曲线上一共有 2n × 2n 个顶点(包括左下角起点和右下角终点)，恰好覆盖每个方格一次。

![](/Img/2017-08-13_23-42.png)

Hn(n > 1)可以通过如下方法构造：

1. 将 Hn-1 顺时针旋转90度放在左下角

2. 将 Hn-1 逆时针旋转90度放在右下角

3. 将2个 Hn-1 分别放在左上角和右上角

4. 用3条单位线段把4部分连接起来

对于 Hn 上每一个顶点 p ，我们定义 p 的坐标是它覆盖的小方格在矩阵中的坐标，定义 p 的序号是它在曲线上从起点开始数第几个顶点。给定 p 的坐标，你能算出 p 的序号吗？ 

---
## 输入
输入包含3个整数 n , x , y 。 n 是分形曲线的阶数，(x, y)是 p 的坐标。

1 ≤ n ≤ 30

1 ≤ x, y ≤ 2n

---
## 输出
p 的序号。

---

## 样例输入
3 6 1


---

## 样例输出
60

---

## 限制
时间限制:10000ms
单点时限:1000ms
内存限制:256MB

---
## 思路
题目中已经说明Hn是由4个Hn-1旋转拼接而成，递归的结构非常明显。所以对于求Hn中(x, y)的序号，我们自然而然会想能否转化成在Hn-1中求(x', y')的序号。

实际上我们只需要考虑Hn中的(x, y)是在左下、左上、右上、右下4个Hn-1中的哪一个里，即可转化成在Hn-1中求(x', y')序号的子问题。具体(x, y)到(x', y')的对应关系涉及到坐标平移和旋转，留给大家思考，不再赘述。

![](/Img/2017-08-16_19-30.png)

以样例为例，如上图所示，H3中的(6, 1)在右下角的H2中，并且对应着H2中(4, 3)这个点。

如果我们能正确求出H2中(4, 3)这个点的序号是12，又因为前3个H2中一共包含16x3=48个点，那么我们就能求出H3中的(6, 1)的序号是12+48=60。

最后需要注意的是n=30时一共包含2^60个点，所以计算序号的时候需要用64位整型存储。

---
## 题解
```
/*
    Author: Yuki
    GitHub: https://github.com/Yuki-14544869/
    Blog:   https://yuki-14544869.github.io/
*/
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, x, y;
    cin >> n >> x >> y;
    int flag = 1, temp; //曲线走势为顺时针时flag为1，走势为逆时针时flag为0
    long long num = 0, N;
    for (int i = n; i >= 1; i--) {
        N = pow(2, i - 1);
        if (x <= N) {
            if (y <= N) { //p点落在1区
                num += (1 - flag) * 3 * N*N;
                temp = y;
                y = x;
                x = N + 1 - temp;
                flag = 1 - flag;
            } else { //p点落在2区
                num += (flag + (1 - flag) * 2)*N*N;
                y -= N;
            }
        } else {
            if (y <= N) { //p点落在4区
                num += flag * 3 * N*N;
                temp = x - N;
                x = y;
                y = N + 1 - temp;
                flag = 1 - flag;
            } else { //p点落在3区
                num += (2 * flag + (1 - flag))*N*N;
                x -= N;
                y -= N;
            }
        }
        if (i == 1) num++;
    }
    cout << num << endl;
    return 0;
}
```
